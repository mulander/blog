---
layout: post
title: KISS with a bit of luck
date: '2014-12-31T02:24:00.000-08:00'
author: Adam Wo≈Çk
tags:
- programming
- perl
modified_time: '2014-12-30T17:25:08.921-08:00'
blogger_id: tag:blogger.com,1999:blog-7611594305180455830.post-4141976429464053267
blogger_orig_url: http://homing-on-code.blogspot.com/2014/12/kiss-with-bit-of-luck.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="/images/kewladmin.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="76" src="/images/kewladmin.png" width="320" /></a></div>I have a habit of digging up old code around the new year, taking a look at it and posting it on <a href="https://github.com/mulander/kewladmin">github</a>. Part of me thinks that I'm doing a bad favour to myself and anyone else that hits that code and decides to uses it. On the other hand looking at your old code is a nice way to see if one have improved in any way over the years. I do stamp warnings all over the place when I do that, so I hope the collateral damage isn't that large.<br /><br />This year I dug up an old Perl script I wrote with a friend of mine almost 9 years ago. This is just an estimation based on the file system timestamps on the server. The oldest files I found were dated back to February / May 2006. That's the deployment time - it was probably written a while back before that.<br /><br />Usually I don't blog when I do that but this time the code is interesting to me in ways that I'll unfold later on.<br /><br /><a name='more'></a><br />KewlAdmin was born because a friend of ours offered a shell service for his friends, he was getting tired of manually defining vhosts for people so asked us to come up with a solution. The requirements set was pretty simple:<br /><br /><ol><li>Authenticate users</li><li>Allow them to view their current disk quota (based on account class)</li><li>Allow to define/remove vhosts</li></ol><br />There were solutions at that time to handle these problem but most software required escalated privileges in order to work.<br /><br />To get this out of the way. The code is in Perl because at that time it was our primary languages and basically we wrote everything in Perl back then :)<br /><br />Why is this code so interesting to me? Mainly four big reasons.<br /><br />1. It doesn't store hashed &amp; salted passwords. In fact it doesn't store any passwords at all.<br />2. It ties in nicely witch existing utilities in *nix that we didn't even think about when we wrote the code.<br />3. It doesn't require root/escalated privileges to do the work<br />4. It was actually in use for at least a couple of years - I made sure with the admin that the code is decommissioned before posting the code itself and this blog post.<br /><br />Don't be fooled. This code is far from perfect. I'll get to the embarrassing bits as soon as we go over those 4 points.<br /><br /><h3>No salt, no hash</h3><div><div>I had a shell on this host and so did my friend. We both didn't want to register yet another account in a web application in order to view our quota usage or to set a new vhost for a quick project. With that in mind how can we authenticate existing shell users without requiring more privileges to the script itself?</div><div><br /></div><div>The solution we came up with seems non-standard and I didn't see it implemented in other software so far. We decided to rely upon ssh and existing credentials. Using the Perl <a href="http://search.cpan.org/~rgiersig/Expect-1.15/Expect.pod">Expect</a> module we opened up a real ssh session to the host itself from our CGI script and passed the users credentials to ssh.</div></div><div><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">## connect via ssh<br />$Expect::Log_Stdout<span class="Apple-tab-span" style="white-space: pre;"> </span>= 0;<br />$ssh = Expect-&gt;new("ssh $login\@localhost");<br />#$ssh-&gt;debug(1);<br />$ssh-&gt;expect(2,qq{$login\@localhost's password:});<br />$ssh-&gt;send($passwd . "\n");<br />unless(scalar $ssh-&gt;expect(2,'$') || $ssh-&gt;expect(2,"Changing password for")) {#$ssh-&gt;expect(2,"Old password:")) {<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>return 0; #unable to login<br />}<br />else {<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>return $ssh; # logged in<br />}</span></blockquote><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span>This choice also allowed one more feature in the panel. Changing passwords.<br />Typical password forms want an old password and the new password repeated twice.<br /><br />If we have the old password we can always authenticate the user with ssh and issue the passwd command changing the password using the existing *nix tool.<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">sub change_pass {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>my ($ip,$login,$old_pass,$new_pass,$repeat_pass) = @_;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>return 0 if $new_pass ne $repeat_pass;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>my $ssh = login($login,$old_pass,$ip);</span><br /><span class="Apple-tab-span" style="white-space: pre;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"> </span></span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>unless(check_shell($login)) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>$ssh-&gt;send("passwd\n");</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>}</span><br /><span class="Apple-tab-span" style="white-space: pre;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"> </span></span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>$ssh-&gt;send("$old_pass\n")<span class="Apple-tab-span" style="white-space: pre;"> </span>if (scalar $ssh-&gt;expect(2,"Old password:"));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>$ssh-&gt;send("$new_pass\n") <span class="Apple-tab-span" style="white-space: pre;"> </span>if (scalar $ssh-&gt;expect(2,"New password:"));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>$ssh-&gt;send("$repeat_pass\n") <span class="Apple-tab-span" style="white-space: pre;"> </span>if (scalar $ssh-&gt;expect(2,"Re-enter new password:"));</span><br /><span class="Apple-tab-span" style="white-space: pre;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"> </span></span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span class="Apple-tab-span" style="white-space: pre;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"> </span></span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>if($ssh-&gt;expect(2,"Password changed.")) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>$ssh-&gt;close;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>return 1;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>return -1;<span class="Apple-tab-span" style="white-space: pre;"> </span></span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><br /><h3>KISS by accident</h3></div><div><div>I think we never realized how much power this solution gave to the system administrator - which is a good thing.</div><div><br /></div><div>OpenSSH is a beast when it comes to functionality. Everything is logged, the crypto is properly implemented (something we wouldn't be able to come close too back then and possibly even now). Since we were basically logging in our users via ssh the system configuration applied to KewlAdmin. Rate limiting, monitoring brute force attacks - everything was available with the basic tools that our sysadmin friend was used to.</div><div><br /></div><div>We did implement a login attempt throttle that banned accounts for an hour after a defined number of attempts based on the source IP. I think that was a good decision back then since OpenSSH would have no way to know the real source IP for the incoming traffic. This also had the benefit of not impacting users shell access just because someone is pounding on the web interface.</div><div><br /></div><div>The way we obtained the quota limits was also interesting because it shelled out via sudo. Properly configured sudo is great and also logs each invocation. It was called by the script itself as user nobody - because we didn't keep the ssh session alive after logging in the user. Again, this is nice because it gave power to a person who new the tools without forcing him to understand our code.</div><div><br /></div><div>Most of all. If someone gained access to the database itself. Including write access. No useful information would be leaked out and changing passwords to existing accounts would remain impossible. Without hashes in the DB there's nothing to crack and nothing to alter.</div><div><br /></div><div>One more thing. If for some reason our admin friend revoked a shell account. He didn't have to remember to do the same in the web interface.</div></div><div><br /></div><h3>Privilege Separation</h3><div><div>Using OpenSSH as our authentication mechanism allowed us to skip escalated privileges while authenticating users.</div><div><br /></div><div>Using sudo to check the quota's allowed us to skip re-authenticating users all the time.</div><div><br /></div><div>The remaining bit was actually altering apache configuration with the potentially changed vhosts.</div><div><br /></div><div>This requires altering a system configuration file and restarting a process. We didn't want the nobody user to be able to do this.</div><div><br /></div><div>The solution was again simple. We had a second script - kewlup.pl. This script was run with escalated privileges on a cron schedule and it's only task was to read the new configuration from the database, rewriting the vhosts file and restarting apache.</div><div><br /></div><div>With those three pieces in-line. Bulk of the code was run as user nobody, with no special privileges and all privileged actions were logged &amp; controlled by standard utilities well understood by system administrators.</div></div><div><br /></div><h3>Living Dead</h3><div><iframe allowfullscreen="" frameborder="0" height="315" src="//www.youtube.com/embed/BvsMPOfblfg" width="420"></iframe></div><div><br /></div><div>The most surprising thing is that this script was actually alive and in use.<br />We never got a 'bug report' against it from any of the users or the admin himself. Though now I see that he did tweak some stuff here &amp; there (like translating error messages from English to Polish, or changing vhosts when he switched domains).<br /><br />Here are some stats grabbed from the database this script used:<br /><br /><ul><li>registered 228 config updates (ka_config.updates) this denotes the number of times the kewlup.pl script runs that resulted in vhost changes.</li><li>ka_domains has 139 entries from 105 users.</li><li>907 entries in ka_users (unique username + ip login attempts)</li><li>417 unique usernames trying to log in</li><li>524 failed login attempts</li></ul><br />There are only 114 users on the server itself, based on the number of unique users and some usernames I saw the site was subject to brute force attacks. The one that stands out the most is for the 'java' account:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">| &nbsp;59 | X.Y.Z.N &nbsp; &nbsp; | java &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp;13 | &nbsp;1153683487|</span><br /><br />There's of course no account on the server with that username.<br /><br /><h3>The ugly</h3></div><div>Now the ugly parts. The most prominent offender is the way we decided to generate the session key.<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">sub genkey {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>my $key ='';</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>my @char = ('a' .. 'z','A' .. 'Z', 0 .. 9);</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>$key &nbsp;.= $char[rand@char] while length $key != 32;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>return $key;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><br />Please never do this. Nowadays I would use an UUID generator making sure it's cryptographically secure before touching it.<br /><br />Though genkey is awful - the way it's used is even uglier.<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">sub create_cookie {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp;# ...</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>$sth = $dbh-&gt;prepare("SELECT id FROM ka_keys WHERE cookie = ?");</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>##</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span># generate until unique key</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>while (1) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>$key = genkey();</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>$sth-&gt;execute($key);</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>last unless $sth-&gt;rows;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp;# ...</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><br />We were hitting the DB to check on each call to make sure that the token we generated is unique in the DB. With a proper UUID you should never do that. Just generate the token and handle a potential error case on insert/update with lot's of logging.<br /><br />Fortunately even with a predicable session key the only thing a hijacked session could do was to alter/add/remove a vhost or view the current quota for an account. That's still far more than I'm comfortable with now but at least there's no obvious way (to me) that an attacker could gain shell access this way.<br /><br />Second thing I'm not proud of is picking MySQL. This one is a bit personal as MySQL is used a lot by a lot of people but I just don't trust it any data any more. When this code was written, I knew nothing about databases except trivial basics. After 7 years with Oracle &amp; around 3 years with PostgreSQL I'm not touching MySQL with a 10 foot pole.<br /><br />The last bit that made me uneasy is actually the shell outs to the commands.<br /><br />Let me list them here:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; # ....</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>if ($_login =~ /^([A-Za-z][-_A-Za-z0-9]{0,29})$/) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">   </span>$login = $1;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; # ....</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>my $uinfo<span class="Apple-tab-span" style="white-space: pre;"> </span>= `finger -mp $login`;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span># ....</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>my $space_used = `sudo du -sm ~$login | awk '{print \$1}'`;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span># ....</span><br /><br />Yes, $login was untained before usage but I'm still uneasy about calling any shell command with string interpolation.<br /><br /><h3>Final thoughts</h3></div><div><div>The code is a mess. It did stood the test of time and I'm somewhat happy that it did. Reading Perl after 9 years wasn't as bad as I expected but my inexperience back then really stands out.</div><div><br /></div><div><ul><li>There is no routing in the code, just a giant if/elsif/else branch for action decision</li><li>Nowadays I avoid regular expressions, back then I used them far too often</li><li>Too much stuff is hardcoded (db credentials, vhosts, account classes)</li><li>Plus all the things mentioned before in this post</li></ul></div><div>I think the saving grace of this piece of code was privilege separation and the use of OpenSSH as the authentication mechanism. Without it I'm sure our friendly shell hosting provider would be brought down by the mere existence of this script.</div><div><br /></div><div>Standing on the shoulder of giants really fits the bill here. I literally didn't look at this code for 9 years, while ssh remained maintained and updated. With each OpenSSH update our script benefited. I doubt that back then we would even think about timing attacks, encryption algorithms, side channel attacks or even just keeping the system accounts in sync with the web interface database. If we didn't went the path we did this script would probably store a salted md5 hash of user credentials and ran with escalated privileges to do it's job.</div><div><br /></div><div>With a bit of luck, it was kept simple and served some users for a couple of years.</div></div>