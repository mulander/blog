---
layout: post
title: Oracle PL/SQL language pitfalls
date: '2011-04-23T04:48:00.000-07:00'
author: Adam Wo≈Çk
tags:
- programming
- plsql
- ada
- oracle
modified_time: '2011-04-23T04:54:38.024-07:00'
blogger_id: tag:blogger.com,1999:blog-7611594305180455830.post-4072105669261157426
blogger_orig_url: http://homing-on-code.blogspot.com/2011/04/oracle-plsql-language-pitfalls.html
---

<a href="http://en.wikipedia.org/wiki/PL/SQL">Oracle PL/SQL</a> is an procedural language for Oracle relational database and tools like Oracle Forms and Reports. The language was based on the <a href="http://en.wikipedia.org/wiki/Ada_(programming_language)">Ada programming language</a> and even uses a variant of <a href="http://en.wikipedia.org/wiki/DIANA_(intermediate_language)">Descriptive Intermediate Attributed Notation for Ada</a> (DIANA). I've been developing in the language for the past 4 years and wanted to share some pitfalls I stumbled upon during this time. Since the language is supposed to be based on Ada I will compare some cases to their counterparts in the Ada language - skipping the ones without obvious mappings (like SQL only code).&nbsp;We will start with a trivial problem and increment to more sophisticated ones.<br /><br /><a name='more'></a>PL/SQL and Ada are both block structured languages where each block can be divided into roughly three sections. The declaration for&nbsp;specifying&nbsp;block-local variables, sub-program units, records etc. The code section containing the algorithmic code and an exception section where exceptions from the current block can be caught and handled. Further language features like package&nbsp;specifications, object oriented programming etc. will not be discussed in this post as they are not required to demonstrate any of our problems. Single line comments in Ada and PL/SQL start with double dash (--), multi-line comments will not be used by us.<br /><br />An example PL/SQL block:<br /><code><br />&lt;&lt;example_block&gt;&gt; -- optional label<br />declare<br />&nbsp;&nbsp;-- variable declarations<br />&nbsp;&nbsp;-- sub program units (functions/procedures)<br />begin<br />&nbsp;&nbsp;-- code<br />exception<br />&nbsp;&nbsp;when exception_name then -- handle a named exception<br />&nbsp;&nbsp; &nbsp;handle_exception();<br />&nbsp;&nbsp;when others then -- catch all exceptions handler<br />&nbsp;&nbsp; &nbsp;handle_all_exceptions();<br />end example_block;</code><br /><br /><code></code>The usage of 'end example_block' is only valid if the block was &lt;&lt;labeled&gt;&gt; otherwise just use 'end;'.<br /><br />Since we got our basics down, we can start with our first problem.<br /><br /><span class="Apple-style-span" style="font-size: x-large;"><b>Weak compile time checks</b></span><br /><br />The longer I work on large legacy code bases the more I appreciate errors caught during compilation.<br /><br />In the following example, a <code>VARCHAR2</code> variable is declared with a length equal to one. You can think about the <code>VARCHAR2</code> type as string. In the declaration section a constant literal <code>'abc'</code> is assigned to this string which exceeds it's capacity.<br /><code><br />set serveroutput ON<br /><br />DECLARE<br />&nbsp;&nbsp;PROCEDURE test_literal IS<br />&nbsp;&nbsp; &nbsp;v_string VARCHAR2(1) := 'abc';<br />&nbsp;&nbsp;BEGIN<br />&nbsp;&nbsp; &nbsp;dbms_output.put_line( v_string );<br />&nbsp;&nbsp;END;<br />BEGIN<br />&nbsp;&nbsp;dbms_output.put_line('Before Call');<br />&nbsp;&nbsp;test_literal();<br />&nbsp;&nbsp;dbms_output.put_line('After Call');<br />END;<br /><br />/<br /></code><br />From the above code, it is obvious that there is a bug which can be determined on compilation - sadly PL/SQL compiles the code without any warnings.<br />We have declared a local procedure in this block to demonstrate that the issue really arises on runtime and not during compilation.<br />Save the code to <code>literal_string.sql</code> and run it in a SQL Plus session.<br /><br /><code><br />SQL&gt; @C:\blog\literal_string.sql<br /><br />Before Call<br /><br />ORA-06502: PL/SQL: numeric or value error: character buffer too small<br />ORA-06512: at line 4<br />ORA-06512: at line 10<br /></code><br /><br />As you probably guessed, this resulted in a run-time exception being raised (ORA-06502). The same problem extends to numbers exceeding the defined precision (ie. <code>NUMBER(2)</code> assigned 100 as a value). Since the value is literal it would be nice if the language at least reported it during compilation. Let's see how a similar example behaves in Ada.<br /><br /><code> with Ada.Text_IO;<br /><br />procedure Literal_String<br />is<br />&nbsp;&nbsp;v_string : String (1 .. 1) := "abc";<br />begin<br />&nbsp;&nbsp;Ada.Text_IO.Put_Line ( v_string );<br />end Literal_String;<br /></code><br /><br />Save the file to <code>literal_string.adb</code> and compile with <code>gnatmake -gnato literal_string.adb</code>.<br /><code><br />mulander@bunkier_mysli:~/code/blog/plsql-pitfalls$ gnatmake -gnato literal_string.adb<br />gcc -c -gnato literal_string.adb<br />literal_string.adb:5:33: warning: wrong length for array of subtype of "Standard.String" defined at line 5<br />literal_string.adb:5:33: warning: "Constraint_Error" will be raised at run time<br />gnatbind -x literal_string.ali<br />gnatlink literal_string.ali<br /></code><br /><br />The <code>-gnato</code> compiler flag enables run-time overflow checks but it doesn't affect this example.<br />The compiler nicely warned us that the length of the assigned string exceeds the allowed range for the variable declared at line 5. The compiler even informed us which exception will be raised on run-time. Adding a <code>-we</code> flag would treat all warnings as errors and wouldn't even produce an executable. We didn't supply the flag so let's run the program.<br /><br /><code><br />mulander@bunkier_mysli:~/code/blog/plsql-pitfalls$ ./literal_string<br /><br />raised CONSTRAINT_ERROR : literal_string.adb:5 length check failed<br />mulander@bunkier_mysli:~/code/blog/plsql-pitfalls$<br /></code><br /><br />We got our runtime exception - exactly the one we were warned about. This may seem trivial but trust me - things like this can sometimes save hours spent on <i>handling</i> a runtime error on a production system.<br /><br />Ada also has a nice syntax for string literal declarations that infers the length from the assignment.<br /><br /><code><br />with Ada.Text_IO;<br /><br />procedure Literal_String_2<br />is<br />v_string : String := "abc";<br />begin<br />Ada.Text_IO.Put_Line ( v_string );<br />end Literal_String_2;<br /></code><br /><br />Save this to <code>literal_string_2.adb</code> and compile with <code>gnatmake -gnato literal_string_2.adb</code>. I'll skip the output as the program behaves correctly and no exceptions are raised.<br /><br />What happens if we assign a literal exceeding the inferred length?<br /><br /><code><br />with Ada.Text_IO;<br /><br />procedure Literal_String_3<br />is<br />&nbsp;&nbsp;v_string : String := "abc";<br />begin<br />&nbsp;&nbsp;v_String := "abcd";<br />&nbsp;&nbsp;Ada.Text_IO.Put_Line ( v_string );<br />end Literal_String_3;<br /></code><br /><br />Save the content to <code>literal_string_3.adb</code> and compile with <code>gnatmake -gnato literal_string_3.adb</code>.<br /><br /><code><br />mulander@bunkier_mysli:~/code/blog/plsql-pitfalls$ gnatmake -gnato literal_string_3.adb<br />gcc -c -gnato literal_string_3.adb<br />literal_string_3.adb:7:15: warning: wrong length for array of subtype of "Standard.String" defined at line 5<br />literal_string_3.adb:7:15: warning: "Constraint_Error" will be raised at run time<br />gnatbind -x literal_string_3.ali<br />gnatlink literal_string_3.ali<br /></code><br /><br />Again we will skip the output. The proper <code>Constraint_Error</code> exception is raised like the compiler promised. You can't imagine how happy I am seeing this behavior. At this point we can move on to our second problem.<br /><br /><span class="Apple-style-span" style="font-size: x-large;"><b>Implicit type conversions</b></span><br />Implicit type conversions are often hard to track down and can lead to significant problems during application run-time. One of the most severe problems caused by them are hard to predict choices when overloaded functions/procedures are involved - this time it's not I what I want to focus on. The specific bug I encountered is really interesting because of the innocent code it appears in and an exception that could be avoided with a more strict compilation phase.<br /><br /><code><br />set serveroutput on<br /><br />DECLARE<br />&nbsp;&nbsp;n_first  NUMBER := 1;<br />&nbsp;&nbsp;n_second NUMBER := 2;<br />BEGIN<br />&nbsp;&nbsp;dbms_output.put_line('Before faulty code');<br />&nbsp;&nbsp;dbms_output.put_line('n_first + n_second ' || n_first + n_second );<br />&nbsp;&nbsp;dbms_output.put_line('After faulty code');<br />END;<br /><br />/<br /></code><br /><br />Imagine for a moment that the middle output statement is a debug log added and left by a programmer in an important part of the system. Let's run the code in SQL Plus:<br /><br /><code><br />SQL&gt; @C:\blog\concat.sql<br /><br />Before faulty code<br /><br />ORA-06502: PL/SQL: numeric or value error: character to number conversion error<br />ORA-06512: at line 7<br /></code><br /><br />Why did this code result in a run-time error? My guess is <a href="http://download.oracle.com/docs/cd/B28359_01/appdev.111/b28370/fundamentals.htm#CHDCDGCF">operator precedence rules</a> and implicit type conversions. From the linked documentation page we can see that +, - and || (addition,&nbsp;subtraction&nbsp;and concatenation operators) have equal precedence and as stated in the document such operators are applied <i>in no particular order</i>. So what happened?<br /><br />The following line:<br /><code><br />dbms_output.put_line('n_first + n_second ' || n_first + n_second );<br /></code><br /><br />Can be further simplified to:<br /><br /><code> procedure_call( string_type CONCAT number_type ADD number_type )</code><br /><br />We know that before the function call the operators will be evaluated so we can drop the call:<br /><br /><code> string_type CONCAT number_type ADD number_type </code><br /><br />Now, since both concatenation and addition are of equal precedence we can start with an assumption that concatenation was performed first (leftmost operation). So number_type was converted to a string and concatenated to our first string_type.<br /><br /><code> string_type ADD number_type </code><br /><br />Now, we are left with an addition operation of a string and a number. Since adding a number to a string doesn't make any sense for the compiler an implicit string to number conversion happens. This operation fails with an obvious run-time exception. A really nasty bug hard to find in such an innocent statement.<br /><br />So how does Ada handle this problem? Easy, <b>no implicit type conversions.</b><br /><br /><code><br />with Ada.Text_IO;<br /><br />procedure Concat is<br />&nbsp;&nbsp;n_first : Integer := 1;<br />&nbsp;&nbsp;n_second: Integer := 2;<br />begin<br />&nbsp;&nbsp;Ada.Text_IO.Put_Line ( "n_first + n_second" &amp; n_first + n_second );<br />end Concat;<br /></code><br /><br />Save the file to <code>concat.adb</code> and compile with <code>gnatmake -gnato concat.adb</code><br /><br /><code><br />mulander@bunkier_mysli:~/code/blog/plsql-pitfalls$ gnatmake -gnato concat.adb<br />gcc -c -gnato concat.adb<br />concat.adb:7:47: invalid operand types for operator "&amp;"<br />gnatmake: "concat.adb" compilation error<br /></code><br /><br />The file doesn't even compile. The concatenation operator <code>&amp;</code> expects a string as it's left and right value. The language will not attempt any implicit conversions even in a simple case like string_type CONCAT number_type. If you want to achieve concatenation of numbers with strings in Ada you need to <b>explicitly </b>cast them:<br /><br /><code><br />with Ada.Text_IO;<br /><br />procedure Concat is<br />&nbsp;&nbsp;n_first : Integer := 1;<br />&nbsp;&nbsp;n_second: Integer := 2;<br />begin<br />&nbsp;&nbsp;Ada.Text_IO.Put_Line ( "n_first + n_second"<br />&nbsp;&nbsp; &nbsp;&amp; Integer'Image(n_first + n_second) );<br />end Concat;<br /></code><br /><br />This time the code compiles without errors and runs with no exceptions raised. It's true that mitigating the problem in PL/SQL is also simple. All one needs to do is to surround the addition of variables with additional parentheses. I still prefer being informed on compilation - even with just a warning. PL/SQL type conversion problems are not limited to simple cases like this but extend to built-in functions. The <code>TO_DATE</code> function when converting a string to a date type can result in an exception being raised which only depends on two variable. The programmer forgetting to specify the string format and the national language support database level variable set to a value which expects a string in a different format than in the provided variable. Bugs like this are annoying to find.<br /><br />We are done with problems that can be compared to Ada directly. The following sections will only relate to PL/SQL.<br /><br /><span class="Apple-style-span" style="font-size: x-large;"><b>Too_Many_Rows exception</b></span><br />Generally the problem with the too_many_rows exception is the moment it's raised. It's best to start with an example:<br /><code><br />set serveroutput on<br /><br />DECLARE<br />&nbsp;&nbsp;n_some_value NUMBER := -1e10;<br />BEGIN<br />&nbsp;&nbsp;BEGIN<br />&nbsp;&nbsp; &nbsp;-- The following rowset will be returned by<br />&nbsp;&nbsp; &nbsp;-- this select statement:<br />&nbsp;&nbsp; &nbsp;--   1<br />&nbsp;&nbsp; &nbsp;--   2<br />&nbsp;&nbsp; &nbsp;-- This will raise a too_many_rows exception<br />&nbsp;&nbsp; &nbsp;SELECT LEVEL<br />&nbsp;&nbsp; &nbsp; &nbsp;INTO n_some_value<br />&nbsp;&nbsp; &nbsp; &nbsp;FROM dual<br />&nbsp;&nbsp; CONNECT BY LEVEL &lt;= 2</code><br /><code>&nbsp;&nbsp; &nbsp; &nbsp;;&nbsp;</code><br /><code>&nbsp;&nbsp;EXCEPTION</code><br /><code>&nbsp;&nbsp; &nbsp;WHEN too_many_rows THEN</code><br /><code>&nbsp;&nbsp; &nbsp; &nbsp;dbms_output.put_line( 'too_many_rows exception' );</code><br /><code>&nbsp;&nbsp; &nbsp; &nbsp;NULL; -- Typical wrong way to handle this case</code><br /><code>&nbsp;&nbsp;END;</code><br /><code>&nbsp;&nbsp;-- So what's the value of n_some_value?</code><br /><code>&nbsp;&nbsp;dbms_output.put_line( 'n_some_value='|| n_some_value  );</code><br /><code>END;</code><br /><code>/ </code><br /><br /><code>n_some_value</code> is being initialized to a constant <code>-1e10</code> then a select into statement performs a query which always returns two rows of data and tries to save it into <code>n_some_value</code>. Raising the <code>too_many_rows</code> exception is of course correct in this case. The problem is at which point is it raised? Try to guess the value of <code>n_some_value</code> printed out at the end of the code and compare it to the actual result:<br /><br /><code><br />SQL&gt; @C:\blog\too_many_rows.sql<br /><br />too_many_rows exception<br />n_some_value=1<br /><br />PL/SQL procedure successfully completed<br /></code><br /><br />You probably expected to see <code>n_some_value=-10000000000</code> on the output right? We got 1 instead. What happened here is the query got executed, the first row was fetched and stored in the variable <code>n_some_value</code>. Since there is more data on the cursor (select into is automatically converted by the database into a cursor fetch) the code is attempting to fetch the second row and in a select into statement only single row queries are allowed so the <code>too_many_rows</code> exception gets raised. Since our variable was set during the first fetch it no longer holds the initialization value of <code>-1e10</code>. This is an easy bug to fix (reinitialize the variable in the exception handler) but it's hard to track down if the error handling code was incorrect or missed this reinitialization in the first place.<br /><br /><span class="Apple-style-span" style="font-size: x-large;"><b>Code optimization</b></span><br />The title of this section might be a bit misleading. I love the fact that the compiler tries hard to optimize away unnecessary code - the problem is that it's hard to sometimes guess what could get optimized away and in specific use cases this can change actual program behavior leading to <a href="http://en.wikipedia.org/wiki/Unusual_software_bug#Heisenbug">Heisenbugs</a>.<br />Please keep in mind, that the only time I hit this bug was a really bad programming approach so the language can't really be blamed for making a wrong&nbsp;decision&nbsp;here but still at least it could be a bit more predictable.<br /><code><br />SET serveroutput ON<br /><br />DECLARE<br />&nbsp;&nbsp;v_date_string VARCHAR2(8) := '20110229'; -- only 28 days in feb 2011<br />&nbsp;&nbsp;b_valid_date &nbsp;NUMBER     := 1;<br />&nbsp;&nbsp;invalid_date &nbsp;EXCEPTION;<br />&nbsp;&nbsp;-- introducing ORA-01839 exception by name<br />&nbsp;&nbsp;pragma exception_init(invalid_date,-01839);<br />BEGIN<br />&nbsp;&nbsp;BEGIN<br />&nbsp;&nbsp; &nbsp;IF TO_DATE ( v_date_string, 'yyyymmdd' ) =<br />&nbsp;&nbsp; &nbsp; &nbsp; TO_DATE ( v_date_string, 'yyyymmdd' )<br />&nbsp;&nbsp; &nbsp;THEN<br />&nbsp;&nbsp; &nbsp; &nbsp;NULL; -- do nothing<br />&nbsp;&nbsp; &nbsp; &nbsp;--dbms_output.put_line('oops');<br />&nbsp;&nbsp; &nbsp;END IF;<br />&nbsp;&nbsp;EXCEPTION<br />&nbsp;&nbsp; &nbsp;WHEN invalid_date THEN<br />&nbsp;&nbsp; &nbsp; &nbsp;b_valid_date := 0;<br />&nbsp;&nbsp;END;<br />&nbsp;&nbsp;-- an important block of logic executed only if the date was valid<br />&nbsp;&nbsp;IF b_valid_date = 1<br />&nbsp;&nbsp;THEN<br />&nbsp;&nbsp; &nbsp;dbms_output.put_line( '... executing ...' );<br />&nbsp;&nbsp;ELSE<br />&nbsp;&nbsp; &nbsp;dbms_output.put_line( '+++ ERROR - invalid date +++' );<br />&nbsp;&nbsp;END IF;<br />END;<br /><br />/<br /></code><br /><br />Save this snippet to <code>opt_away_simple.sql</code> and run it in SQL Plus.<br /><br /><code><br />SQL&gt; @C:\blog\opt_away_simple.sql<br /><br />... executing ...<br /><br />PL/SQL procedure successfully completed<br /><br />SQL&gt; <br /></code><br /><br />In this and all of the following snippets we expect to see <code>+++ ERROR - invalid date +++</code> as the output of the program. Here is the&nbsp;convoluted&nbsp;logic that was supposed to guarantee date validation. The oracle <code>TO_DATE(string,format)</code> function can convert a string in date format to a date type. If the date matches the format but the date is incorrect (ie. 29 Feb 2011) an ORA-01839 exception will be raised which stands for <i>date not valid for month specified</i>. In the exception handler a control variable is set to 0 marking that the date was not valid. Now try to uncomment the put_line statement inside the <code>IF</code> control structure. Running with the uncommented code will give us the expected behavior. See how nasty that would be to debug?<br />To the point. Why is the code behaving this way? The PL/SQL compiler decided that the whole begin/exception/end block containing the if&nbsp;statement&nbsp;and exception handling code is not needed hence it was optimized away during compilation. The code literally does not exist after compilation. Here is my guess why:<br />The <code>TO_DATE()</code> function has no side effects. It doesn't modify any tables, doesn't return any values that get stored to a variable and doesn't insert any rows to tables. The only implicit side effect it has is a possible exception being raised if the provided date string is incorrect. The condition in the if statement also has no side effects except for the possible exception from <code>TO_DATE()</code> and at both sides of the equality comparison the input parameters to <code>TO_DATE()</code> are exactly the same. Since the function is deterministic (always returns the same output for a given set of input parameters) for the compiler this look like code that <b>always</b>&nbsp;evaluates to truth. The code section for the if statement is <code>NULL</code> which stands for a <i>do nothing</i>&nbsp;operation. In this case the whole if is a <i>do nothing </i>operation so the compiler decides to remove it. Since there is no longer any code that can raise the invalid_date exception the control flag will not be set hence our unexpected behavior.<br /><br />Now here is the really funny part. Let's modify the code to use a boolean variable instead of a number. No other changes to the code and all of the above still remains valid (my reasoning for optimizing away the code).<br /><br /><code> SET serveroutput ON<br /><br />DECLARE<br />&nbsp;&nbsp;v_date_string VARCHAR2(8) := '20110229'; -- only 28 days in feb 2011<br />&nbsp;&nbsp;b_valid_date &nbsp;BOOLEAN     := TRUE;<br />&nbsp;&nbsp;invalid_date &nbsp;EXCEPTION;<br />&nbsp;&nbsp;-- introducing ORA-01839 exception by name<br />&nbsp;&nbsp;PRAGMA exception_init(invalid_date,-01839);<br />BEGIN<br />&nbsp;&nbsp;BEGIN<br />&nbsp;&nbsp; &nbsp;IF TO_DATE( v_date_string, 'yyyymmdd' ) =<br />&nbsp;&nbsp; &nbsp; &nbsp; TO_DATE( v_date_string, 'yyyymmdd' )<br />&nbsp;&nbsp; &nbsp;THEN<br />&nbsp;&nbsp; &nbsp; &nbsp;NULL; -- do nothing<br />&nbsp;&nbsp; &nbsp; &nbsp;--dbms_output.put_line('oops');<br />&nbsp;&nbsp; &nbsp;END IF;<br />&nbsp;&nbsp;EXCEPTION<br />&nbsp;&nbsp; &nbsp;WHEN invalid_date THEN<br />&nbsp;&nbsp; &nbsp; &nbsp;b_valid_date := FALSE;<br />&nbsp;&nbsp;END;<br />&nbsp;&nbsp;-- an important block of logic executed only if the date was valid<br />&nbsp;&nbsp;IF b_valid_date<br />&nbsp;&nbsp;THEN<br />&nbsp;&nbsp; &nbsp;dbms_output.put_line( '... executing ...' );<br />&nbsp;&nbsp;ELSE<br />&nbsp;&nbsp; &nbsp;dbms_output.put_line( '+++ ERROR - invalid date +++' );<br />&nbsp;&nbsp;END IF;<br />END;<br /><br />/<br /></code><br /><br />Save this snippet to <code>opt_away_bool.sql</code> and run it in SQL Plus.<br /><br /><code><br />SQL&gt; @C:\blog\opt_away_bool.sql<br /><br />+++ ERROR - invalid date +++<br /><br />PL/SQL procedure successfully completed<br /><br />SQL&gt; <br /></code><br /><br />Now this is interesting. Changing <b>just</b>&nbsp;the type of our control variable made the code behave correctly - I really have no idea why in this case the code was not optimized away like when we used a number.<br />Here is an even more interesting example. Let's change the if statement checking the control variable from <code>IF b_valid_date</code> to <code>IF b_valid_date = TRUE</code>.<br /><br /><code> SET serveroutput ON<br /><br />DECLARE<br />&nbsp;&nbsp;v_date_string VARCHAR2(8) := '20110229'; -- only 28 days in feb 2011<br />&nbsp;&nbsp;b_valid_date &nbsp;BOOLEAN     := TRUE;<br />&nbsp;&nbsp;invalid_date  exception;<br />&nbsp;&nbsp;-- introducing ORA-01839 exception by name<br />&nbsp;&nbsp;pragma exception_init(invalid_date,-01839);<br />BEGIN<br />&nbsp;&nbsp;BEGIN<br />&nbsp;&nbsp; &nbsp;IF TO_DATE( v_date_string, 'yyyymmdd' ) =<br />&nbsp;&nbsp; &nbsp; &nbsp; TO_DATE( v_date_string, 'yyyymmdd' )<br />&nbsp;&nbsp; &nbsp;THEN<br />&nbsp;&nbsp; &nbsp; &nbsp;NULL; -- do nothing<br />&nbsp;&nbsp; &nbsp; &nbsp;--dbms_output.put_line('oops');<br />&nbsp;&nbsp; &nbsp;END IF;<br />&nbsp;&nbsp;EXCEPTION<br />&nbsp;&nbsp; &nbsp;WHEN invalid_date THEN<br />&nbsp;&nbsp; &nbsp; &nbsp;b_valid_date := FALSE;<br />&nbsp;&nbsp;END;<br />&nbsp;&nbsp;-- an important block of logic executed only if the date was valid<br />&nbsp;&nbsp;IF b_valid_date = TRUE<br />&nbsp;&nbsp;THEN<br />&nbsp;&nbsp; &nbsp;dbms_output.put_line( '... executing ...' );<br />&nbsp;&nbsp;ELSE<br />&nbsp;&nbsp; &nbsp;dbms_output.put_line( '+++ ERROR - invalid date +++' );<br />&nbsp;&nbsp;END IF;<br />END;<br /><br />/<br /></code><br /><br />Save this snippet to <code>opt_away_bool_bad.sql</code> and run it in SQL Plus.<br /><br /><code><br />SQL&gt; @C:\blog\opt_away_bool_bad.sql<br /><br />... executing ...<br /><br />PL/SQL procedure successfully completed<br /><br />SQL&gt; <br /></code><br /><br />We are back to our incorrect behavior just with a single line change <b>outside</b>&nbsp;the scope of the optimized away block. Sadly I am not aware of any utilities that could help us review the decisions made by the compiler. The last two snippets will remain a&nbsp;mystery for some time.<br /><br /><span class="Apple-style-span" style="font-size: x-large;"><b>Summary</b></span><br />I really&nbsp;despised the language at first but as time passed by I really started to like large parts of it.&nbsp;PL/SQL is not a bad language but it's a shame that even though in large part it was based on Ada, the language designers decided to skip some of it's features - especially the really strong type system. I can imagine that some of the gripes with the language remain in order to maintain backwards compatibility and that new language features are slowly being added in. I have a final suggestions for everyone working with a language that isn't considered <i>the cool kid</i>&nbsp;in the industry/community: try to understand the inner workings of the tool you use - it may bring new interest to an otherwise mundane task.