---
layout: post
title: Code rot & OpenBSD
date: '2015-01-03T14:14:00.000-08:00'
author: Adam Wołk
tags:
- openbsd
modified_time: '2015-01-03T18:18:19.689-08:00'
thumbnail: http://1.bp.blogspot.com/-2vPmEBFqtkk/VKhST0eZ_mI/AAAAAAAAEXQ/9gN6gD-QEbI/s72-c/2015-01-03%2B21.30.21.jpg
blogger_id: tag:blogger.com,1999:blog-7611594305180455830.post-5156770333949035023
blogger_orig_url: http://homing-on-code.blogspot.com/2015/01/code-rot-openbsd.html
---

<br /><a href="http://1.bp.blogspot.com/-2vPmEBFqtkk/VKhST0eZ_mI/AAAAAAAAEXQ/9gN6gD-QEbI/s1600/2015-01-03%2B21.30.21.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://1.bp.blogspot.com/-2vPmEBFqtkk/VKhST0eZ_mI/AAAAAAAAEXQ/9gN6gD-QEbI/s1600/2015-01-03%2B21.30.21.jpg" height="320" width="240" /></a>I've been often asked by friends why I'm diving into OpenBSD. This post is meant as a single place I can send people to in order to explain to them when, how &amp; why all of this happend.<br /><br />At my previous job I worked with a 2 mln LoC code base for a core banking system. This was a huge project developed by a large development team (~60 devs), with constant change as new features were ordered by clients and a steady flow of issues to fix. Both required delivery 'by yesterday' leaving not much time for clean-ups.<br /><br />One of my friends nicely described the process during an ugly hot-fix as 'powdering the corpse'.<br /><br /><a name='more'></a><br /><br />There was literally no time to slow down, look at the big picture and clean up the accumulated cruft. This did change towards the better during my last year there but for 7 years rapid change was the norm.<br /><br />Imagine working with a code-base, that's layer upon layer of quick fixes. Imagine being woken up at 3 am to diagnose &amp; resolve an issue with it. It was workable, but also felt like being trapped in a pressure cooker. I gave my 3 month leave notice to my employer at the end of March 2014.<br /><br />Things changed radically on that day. My regular tasks were:<br /><ul><li>team management (I was a team leader)</li><li>fixing bugs in the code</li><li>implementing features</li></ul>After giving my notice I was generally given a free hand with one general direction:<br /><ul><li>Pass down knowledge</li></ul>So I did my best.<br /><br />With a system that large, no single person knew the whole thing in and out. Like everyone else I had my 'area' of expertise with the code base. What I started was a slow code review of each functionality that I was part of implementing for<br />the past 7 years. Documenting:<br /><ul><li>what we knew while implementing it</li><li>what we found out after shipping it</li><li>the actual state of the code</li></ul>The results were more then horrifying:<br /><ul><li>I found functionality broken by subsequent fixes</li><li>fixes that were no longer relevant (dead code)</li><li>duplicated code based on old functionality that didn't have recent fixes applied to them</li><li>actual issues caused by refactorization in yet undeployed code, that would be catastrophic on deployment</li><li>potential changes that would result in 15-25% performance increases in critical tasks</li></ul>After those revelations I did three things:<br /><ul><li>obtained a green card for code clean-ups/modifications from upper management</li><li>raised alerts on code that would break on deployments</li><li>passed down knowledge to my team mates on the areas I had any insight for</li></ul>The last 3 months at that job were the best ones I had in seven years. I removed code daily, to the point that I started to believe that half the code could be removed from the system while still keeping the same functionality. I remember joking in a room to friends about removing a 300-500 LoC function and mentioning the '50% code is not needed' line - wondering if I ever find a 'module' that could be completely dropped. To which one of my friends replied that he knows at least one. So I took a look. That was the day I removed 60k lines of dead code in a single go. Fun fact? That code received regular bug fixes - just in case.<br /><br />During that time, heartbleed happened.<br /><br /><h3>Heart Bleed </h3>The company wasn't really affected by heartbleed. That was more personal. I am a regular *nix user since the 90s and really kept following the news. Article after article demonizing the OpenSSL code base, counting how much resources are needed to plumb it into shape, how the original maintainers - let's not go there. Let's say 'didn't do a great job'.<br /><br />Talk is cheap. The news quickly started to get boring. Then LibreSSL happened. I don't remember how I first found the CVS commit for the start of the project. Though you can find my <a href="https://plus.google.com/102090077582777383295/posts/aTMugvcP7ch">G+ post</a> on it which perfectly sums up how I felt back then:<br /><br /><blockquote class="tr_bq">14 Apr 2014<br />So instead of bike shedding like the rest of the internet is doing on the state of OpenSSL.<br />The OpenBSD team silently started putting the beast into shape - <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/lib/libssl/src/ssl/%EF%BB%BF">http://www.openbsd.org/cgi-bin/cvsweb/src/lib/libssl/src/ssl/﻿</a></blockquote><br />I really felt connected with that. They were ripping through thousands of lines of legacy code and ripping it out - same thing as I did daily for my last 3 months.<br /><br />During the time I was leaving, the company started gathering metrics about the codebase with Sonar. After I left one of my ex-co-wokers said that there was a moment when the management wondered why the codebase shrunk by 200k LoC. It was summed up as 'Adam probably removed them'.<br /><br /><h3>Koparo</h3>I have more leeway at <a href="https://koparo.com/">Koparo</a>. Even though the codebase is much smaller it still accumulates cruft that needs to be pruned regularly to allow a more flexible path forward. There are of course periods of time where we move forward on such a fast pace that some solutions aren't as good as they should - the difference is that we go back and kill off all the fallout.<br /><br />Go back and look at the kind of issues a simple code review required to prepare a presentation revealed. That stumps me even to this day. We do code reviews at Koparo for each change - they are just too good to pass off even during the<br />high churn times.<br /><br /><h3>OpenBSD </h3>The background is set, you know why I took interest now it's time to tell what solidified the decision.<br /><br />Each change made to the OpenBSD codebase undergoes a code review before it's committed to the tree. If you managed to get that far in this article you perfectly know why I deem that of upmost importance.<br /><br />No matter how many features your software has, if your documentation is sub-par then your software is most likely useless. The quality of OpenBSD documentation is on a level I didn't expect even after reading about it in so many places. Not only will you get information on how something works, what's possible and how to use it. It will also tell you the best practices for using the tool and warn you about the common pitfalls.<br /><br />Release cycles. Remember those bugs I found that would break the next deployment? Time to ship at my previous job was counted in months before code hit the machines of our clients. In OpenBSD you are encouraged to run current. The whole team tries it's best to make it as stable as it can. You know why? They eat their own dog food. That's so simple yet so amazing that it blows my mind. Developers actually run OpenBSD on their machines daily. Development isn't done on virtual machines on a Macbook Pro. If current fails then you can be guaranteed that a solid userbase of people able to fix it will also have a large interest in doing so. They also ship like clockwork - this speaks miles of the quality this  project outputs. You can count on a OpenBSD release being here every 6  months. Go ahead, sync your clock against it.<br /><br />Which nicely brings us to the next point. Stuff is compiled on actual hardware. i386? amd64? VAX? you can be sure to hit obscure problems on real hardware - not so much on virtualized systems. Personally I am glad that software running on my MSI Wind i386 machine was actually compiled on a i386 machine not on some virtualized host.<br /><br />Do it right or don't do it at all. This shows up in OpenBSD development a lot. Yes it's not nice that the Realtek 8187SE wifi chip in this laptop is not supported by OpenBSD. Though it's also not funny that this driver is of such low quality that even the Linux kernel will only take it into the staging area. Distributions that somewhat worked with this card now plainly refuse to do so without manual intervention. Whose fault is it? Mine. I bought this laptop for my wife as it came with SUSE SLED preinstalled so I assumed it will have no hardware issues - boy was I wrong. If Opera didn't take down my blog I would gladly link you to the whole story (I have a backup, hit me up on email or comment below if you're curious). Nowadays I shop for hardware with a bootable OpenBSD thumbstick. There's no better insurance for hardware support than booting up the installer, dropping to the shell and checking dmesg for not configured devices. If OpenBSD states that something is configured then it works and will remain working flawlessly or will only get better over time.<br /><br />There is so much more to it. That I don't even know if I should keep going. Exploit mitigation, security research &amp; modern core tool reimplementations to name the few things that OpenBSD is doing on a regular basis. Funny, that the only thing that didn't really change since my early *nix days is the usage of OpenSSH. Regardless of platform. If that doesn't speak to you then I don't know what else to name.<br /><br /><h3>Getting Started</h3>I described this once in an email to <a href="http://bsdnow.tv/">BSDNow</a>. Here is a small excerpt:<br /><blockquote class="tr_bq">The approach I took is as follows:<br /><ol><li>&nbsp;I subscribed to OpenBSD mailing lists (cvs, bugs, misc, tech) - I'm learning tons from just following the discussions</li><li>&nbsp;I started running OpenBSD in a qemu instance on my current box - I intend to follow current on it</li><li>&nbsp;I'm learning the system by usage in qemu and following changes from recent commits on the tree</li></ol></blockquote>Those were my baby steps. Since then I also installed OpenBSD on bare metal. Thanks to my lovely wife who donated her MSI Wind for this purpose. So I ordered a CD set. I did not need one. The MSI Wind doesn't even have a CD-ROM, the order was plainly to support the project that benefited me for such a long time.<br /><br />Here are some things I found since starting my journey:<br /><ol><li>OpenBSD sources on the hard drive</li><li>following the lists</li><li>qt5 port</li><li>gdb </li></ol><h4>&nbsp;</h4><h3>Lesson 1 sources on the hdd</h3>This might sound simple but in a long time I didn't feel so connected to my OS. Having the sources for every piece of software I use around made things really different. How? I'm actually looking at them. I used Linux for a really long time but rarely took the time to dive down into what happens when a specific thing occurred in my OS, desktop, software etc. Not the case with OpenBSD - I'll gladly drop into the debugger and see what <b>really</b> is going on.<br /><h4>&nbsp;</h4><h3>Lesson 2 following the lists</h3>Mailing lists are verbose, especially if you decide to subscribe to as many as I did. Honestly though I don't regret it. There's so much gold hidden there that even going through 5-10 emails per day often leads me into areas that I would not otherwise hit. It expands my mind and I'm really happy about it.<br /><h4>&nbsp;</h4><h3>Lesson 3 qt5 port</h3>I managed to contribute. Not in a big way. I really want to port <a href="http://otter-browser.org/">otter-browser</a> to OpenBSD so I started to work on it. While doing that I hit some bugs in the Qt5 port in OpenBSD and reported it upstream which resulted in at least <a href="http://www.freshbsd.org/commit/openbsd-ports/9950ce433191646aeddc833151e7e87964b801f8">one patch</a> due to my reporting.<br /><br />Pause here for a moment. OpenBSD has a reputation of harsh mailing lists. Show me one more system when you can reach core developers, maintainers etc. - get them to answer your questions and even act on your reports. I can take a lot of beating for that privilege.<br /><br />I learned more in a couple of months on the OpenBSD mailing lists then in the past year of self passive research.<br /><h4>&nbsp;</h4><h3>Lesson 4 gdb</h3>Funny to plug in gdb here. I never had a need to learn it really well but now I want to. Having a large established code base to actually debug and experienced people to ask around really helps. During the last three weeks I learned more about gdb then in the last decade of Linux usage.<br /><h3>&nbsp;</h3><h3>Finally</h3>The OpenBSD Foundation is finishing up the <a href="http://www.openbsdfoundation.org/campaign2014.html">fund raiser for 2014</a>. Should you donate? Did you use OpenSSH today? You should.<br /><br />In summary I'm learning more then ever - computing is fun again.